#include "trace.h"

#include <cassert>
#include <cstdint>
#include <cstdlib>

#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

#include "ir.h"

void test(int pc) {

}

|.arch x64

void Trace::compile() {
  // Compilation using DynASM is very much inspired by the follow tutorial:
  // https://corsix.github.io/dynasm-doc/tutorial.html
  // Many thanks to Peter Cawley for documentation and to Mike Pall for DynASM.
  // Please refer to LICENSE for details.
  dasm_State *d;

  |.section code
  dasm_init(&d, DASM_MAXSECTION);

  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);

  |.actionlist bf_actions
  dasm_setup(&d, bf_actions);

  |.define PTR, r12
  |.define PUTCHAR, r13
  |.define SCRATCH1, r14
    |.define SCRATCH1b, r14b
  |.define SCRATCH2, r15
    |.define SCRATCH2b, r15b

  dasm_State** Dst = &d;
  |.code
  |->bf_trace:

  | push PTR
  | push PUTCHAR
  | push SCRATCH1
  | push SCRATCH2
  | mov PTR, rdi

  // https://www.corsix.org/content/calling-external-functions-x64-dynasm
  | mov64 PUTCHAR, (uint64_t)(intptr_t)&putchar

  |->loop:
  for (const auto *ir : instrs) {
    switch (ir->getOp()) {
    case IncPtr:
      | add PTR, ir->getA();
      break;
    case DecPtr:
      | sub PTR, ir->getA();
      break;
    case IncByte:
      | add byte [PTR + ir->getB()], ir->getA()
      break;
    case DecByte:
      | sub byte [PTR + ir->getB()], ir->getA()
      break;
    case PutChar:
      | movzx rdi, byte [PTR + ir->getB()]
      | call PUTCHAR
      break;
    case GetChar:
      assert(false);
      break;
    case Label:
      | cmp byte [PTR], 0
      | jz ->cleanup
      break;
    case Jmp:
      | jmp ->loop
      break;
    case Assign:
      | mov byte [PTR], ir->getA();
      break;
    case MulAdd:
      | mov SCRATCH2b, byte [PTR]
      | imul SCRATCH2, ir->getA()

      | mov SCRATCH1b, byte [PTR + ir->getB()]
      | add SCRATCH1b, SCRATCH2b
      | mov byte [PTR + ir->getB()], SCRATCH1b
      break;
    case MulSub:
      | mov SCRATCH2b, byte [PTR]
      | imul SCRATCH2, ir->getA()

      | mov SCRATCH1b, byte [PTR + ir->getB()]
      | sub SCRATCH1b, SCRATCH2b
      | mov byte [PTR + ir->getB()], SCRATCH1b
      break;
    case Jit:
    case Hlt:
      assert(false);
      break;
    }
  }

  |->cleanup:

  | mov rax, PTR

  | pop SCRATCH2
  | pop SCRATCH1
  | pop PUTCHAR
  | pop PTR

  | ret

  dasm_link(&d, &mcodeSz);

  mcode =  mmap(0, mcodeSz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, mcode);
  mprotect(mcode, mcodeSz, PROT_READ | PROT_EXEC);

  dasm_free(&d);

  // free IR to save memory
  std::vector<const IR *>().swap(instrs);
}
