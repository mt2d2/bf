#include "trace.h"

#include <cassert>
#include <cstdint>
#include <cstdlib>

#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

|.arch x64

void Trace::compile() {
  // Compilation using DynASM is very much inspired by the follow tutorial:
  // https://corsix.github.io/dynasm-doc/tutorial.html
  // Many thanks to Peter Cawley for documentation and to Mike Pall for DynASM.
  // Please refer to LICENSE for details.
  dasm_State *d;

  |.section code
  dasm_init(&d, DASM_MAXSECTION);

  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);

  |.actionlist bf_actions
  dasm_setup(&d, bf_actions);

  |.define PTR, rbx
  |.define PUTCHAR, rbp

  dasm_State** Dst = &d;
  |.code
  |->bf_trace:

  | push PTR
  | push PUTCHAR
  | mov PTR, rdi
  | mov PUTCHAR, putchar

  for (const auto *ir : instrs) {
    switch (ir->getOp()) {
    case IncPtr:
      | add PTR, ir->getA();
      break;
    case DecPtr:
      | sub PTR, ir->getA();
      break;
    case IncByte:
      | add byte [PTR + ir->getB()], ir->getA();
      break;
    case DecByte:
      | sub byte [PTR + ir->getB()], ir->getA();
      break;
    case PutChar:
      | movzx rdi, byte [PTR]
      | call PUTCHAR
      break;
    case GetChar:
      break;
    case Label:
      break;
    case Jmp:
      break;
    case Assign:
      | mov byte [PTR], ir->getA();
      break;
    case MulAdd:
      break;
    case MulSub:
      break;
    case Hlt:
      assert(false);
      break;
    }
  }

  | mov rax, PTR

  | pop PUTCHAR
  | pop PTR

  | ret

  dasm_link(&d, &mcodeSz);

  // todo, need to mmap and mprotect
  mcode =  mmap(0, mcodeSz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, mcode);
  mprotect(mcode, mcodeSz, PROT_READ | PROT_EXEC);

  dasm_free(&d);

  // free IR to save memory
  std::vector<const IR *>().swap(instrs);
}
